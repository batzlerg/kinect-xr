<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kinect + Three.js - Depth Point Cloud</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: monospace;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 12px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 4px;
      z-index: 100;
      user-select: none;
    }
    #status {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 4px;
      z-index: 100;
    }
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 14px;
      background: rgba(0,0,0,0.8);
      padding: 15px 20px;
      border-radius: 4px;
      z-index: 100;
      text-align: center;
      transition: opacity 0.5s;
    }
    #instructions.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .connected { color: #4ade80; }
    .disconnected { color: #f87171; }
    .loading { color: #fbbf24; }
  </style>
</head>
<body>
  <div id="info">
    <strong>Kinect XR + Three.js</strong><br>
    Real-time depth point cloud<br><br>
    <span id="fps">FPS: --</span><br>
    <span id="points">Points: --</span><br>
    <span id="depth-range">Depth: -- to -- mm</span>
  </div>
  <div id="status" class="loading">Connecting...</div>
  <div id="instructions">
    <strong>Controls</strong><br>
    Left Click + Drag: Rotate view<br>
    Right Click + Drag: Pan view<br>
    Scroll: Zoom in/out
  </div>

  <!-- Three.js from CDN -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { KinectClient, KINECT } from '../../lib/kinect-client.js';

    // Configuration
    const SAMPLE_STEP = 4;  // Sample every Nth pixel (4 = 40,000 points, 8 = 10,000 points)
    const POINT_SIZE = 2.0;
    const DEPTH_SCALE = 0.001;  // Convert mm to meters for visualization

    // WebGL capability check
    if (!window.WebGLRenderingContext) {
      document.getElementById('status').textContent = 'WebGL not supported';
      document.getElementById('status').className = 'disconnected';
      throw new Error('WebGL not available');
    }

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Camera setup (positioned to view from front)
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 3);

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // OrbitControls for camera interaction
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 1;
    controls.maxDistance = 10;
    controls.target.set(0, 0, 0);

    // Hide instructions after first interaction
    let hasInteracted = false;
    const instructions = document.getElementById('instructions');
    controls.addEventListener('start', () => {
      if (!hasInteracted) {
        hasInteracted = true;
        instructions.classList.add('hidden');
      }
    });

    // Grid helper for reference
    const gridHelper = new THREE.GridHelper(4, 20, 0x404040, 0x202020);
    gridHelper.position.y = -1;
    scene.add(gridHelper);

    // Axes helper (X=red, Y=green, Z=blue)
    const axesHelper = new THREE.AxesHelper(1);
    scene.add(axesHelper);

    // Point cloud geometry and material
    const maxPoints = Math.ceil((KINECT.WIDTH / SAMPLE_STEP) * (KINECT.HEIGHT / SAMPLE_STEP));
    const geometry = new THREE.BufferGeometry();

    // Pre-allocate buffers (positions and colors)
    const positions = new Float32Array(maxPoints * 3);  // x, y, z
    const colors = new Float32Array(maxPoints * 3);     // r, g, b

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Set initial draw range to 0 (no points visible initially)
    geometry.setDrawRange(0, 0);

    // Point material with vertex colors
    const material = new THREE.PointsMaterial({
      size: POINT_SIZE,
      vertexColors: true,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.8
    });

    const pointCloud = new THREE.Points(geometry, material);
    scene.add(pointCloud);

    // Kinect client setup
    const kinect = new KinectClient();
    let depthData = null;
    let connected = false;
    let pointCount = 0;

    // Only subscribe to depth stream (RGB not needed)
    kinect.setStreams(['depth']);

    kinect.onDepthFrame = (depth, frameId) => {
      depthData = depth;
    };

    kinect.onConnect = (caps) => {
      connected = true;
      document.getElementById('status').textContent = 'Connected';
      document.getElementById('status').className = 'connected';
      console.log('[Three.js] Kinect connected, capabilities:', caps);
    };

    kinect.onDisconnect = () => {
      connected = false;
      document.getElementById('status').textContent = 'Disconnected';
      document.getElementById('status').className = 'disconnected';
    };

    kinect.onError = (err) => {
      document.getElementById('status').textContent = `Error: ${err.message || err.code}`;
      document.getElementById('status').className = 'disconnected';
    };

    // Connect to Kinect bridge
    kinect.connect().catch(err => {
      document.getElementById('status').textContent = 'Connection failed - is bridge running?';
      document.getElementById('status').className = 'disconnected';
      console.error('[Three.js] Connection error:', err);
    });

    // Update point cloud from depth data
    function updatePointCloud() {
      if (!depthData) return;

      const positionAttr = geometry.getAttribute('position');
      const colorAttr = geometry.getAttribute('color');
      const positions = positionAttr.array;
      const colors = colorAttr.array;

      let pointIdx = 0;
      let minDepth = Infinity;
      let maxDepth = 0;

      // Sample depth data and convert to 3D points
      for (let y = 0; y < KINECT.HEIGHT; y += SAMPLE_STEP) {
        for (let x = 0; x < KINECT.WIDTH; x += SAMPLE_STEP) {
          const depthIdx = y * KINECT.WIDTH + x;
          const depth = depthData[depthIdx];

          // Only use valid depth values
          if (depth >= KINECT.MIN_DEPTH_MM && depth <= KINECT.MAX_DEPTH_MM) {
            // Convert to 3D coordinates (meters)
            // X: left to right (mirrored for natural view)
            // Y: top to bottom (inverted for natural orientation)
            // Z: depth (closer = positive, further = negative)
            const px = (KINECT.WIDTH - x - KINECT.WIDTH / 2) * DEPTH_SCALE;
            const py = (KINECT.HEIGHT / 2 - y) * DEPTH_SCALE;
            const pz = -depth * DEPTH_SCALE + 2;  // Offset to center in view

            positions[pointIdx * 3 + 0] = px;
            positions[pointIdx * 3 + 1] = py;
            positions[pointIdx * 3 + 2] = pz;

            // Color mapping: close = warm (red/orange), far = cool (cyan/blue)
            const normalizedDepth = (depth - KINECT.MIN_DEPTH_MM) / (KINECT.MAX_DEPTH_MM - KINECT.MIN_DEPTH_MM);

            // HSL-like color gradient (hue from 0 to 240 degrees)
            const hue = normalizedDepth * 240;
            const color = hslToRgb(hue, 80, 60);

            colors[pointIdx * 3 + 0] = color.r;
            colors[pointIdx * 3 + 1] = color.g;
            colors[pointIdx * 3 + 2] = color.b;

            // Track depth range for stats
            minDepth = Math.min(minDepth, depth);
            maxDepth = Math.max(maxDepth, depth);

            pointIdx++;
          }
        }
      }

      // Update geometry with new data
      positionAttr.needsUpdate = true;
      colorAttr.needsUpdate = true;
      geometry.setDrawRange(0, pointIdx);

      pointCount = pointIdx;

      // Update stats
      document.getElementById('points').textContent = `Points: ${pointCount.toLocaleString()}`;
      document.getElementById('depth-range').textContent =
        `Depth: ${minDepth.toFixed(0)} to ${maxDepth.toFixed(0)} mm`;
    }

    // Convert HSL to RGB (for color mapping)
    function hslToRgb(h, s, l) {
      h = h / 360;
      s = s / 100;
      l = l / 100;

      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      return { r, g, b };
    }

    // FPS counter
    let lastTime = performance.now();
    let frameCount = 0;
    let fps = 0;

    function updateFPS() {
      frameCount++;
      const now = performance.now();
      const elapsed = now - lastTime;

      if (elapsed >= 1000) {
        fps = Math.round((frameCount * 1000) / elapsed);
        document.getElementById('fps').textContent = `FPS: ${fps}`;
        frameCount = 0;
        lastTime = now;
      }
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Update point cloud from latest depth data
      updatePointCloud();

      // Update controls
      controls.update();

      // Render scene
      renderer.render(scene, camera);

      // Update FPS counter
      updateFPS();
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (kinect) kinect.disconnect();
      renderer.dispose();
      geometry.dispose();
      material.dispose();
    });

    // Start animation loop
    animate();
  </script>
</body>
</html>
